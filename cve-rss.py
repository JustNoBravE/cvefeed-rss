import requests
import requests
import feedparser
import json
import time
import smtplib
import os
from datetime import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# 从环境变量获取配置
RSS_URL = "https://cvefeed.io/rssfeed/severity/high.xml"
SMTP_SERVER = os.environ.get("SMTP_SERVER")
SMTP_PORT = int(os.environ.get("SMTP_PORT", 465))
SENDER_EMAIL = os.environ.get("SENDER_EMAIL")
SENDER_PASSWORD = os.environ.get("SENDER_PASSWORD")
RECIPIENT_EMAIL = os.environ.get("RECIPIENT_EMAIL")
DATA_FILE = "cve_vulnerabilities.json"

def initialize_json():
    # 确保总是创建文件，即使为空
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump([], f, ensure_ascii=False, indent=2)

def get_cve_id(title):
    import re
    match = re.search(r'CVE-\d{4}-\d{4,7}', title)
    return match.group() if match else "未知编号"

def fetch_and_save_cve():
    try:
        # 检查是否使用本地文件
        if os.path.exists('high.xml'):
            with open('high.xml', 'r', encoding='utf-8') as f:
                feed = feedparser.parse(f.read())
        else:
            response = requests.get(RSS_URL, timeout=10)
            response.raise_for_status()
            feed = feedparser.parse(response.content)

        initialize_json()
        
        existing_data = []
        existing_ids = set()
        if os.path.getsize(DATA_FILE) > 0:
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                existing_data = json.load(f)
                for item in existing_data:
                    existing_ids.add(item['cve_id'])
        
        new_entries = 0
        for entry in feed.entries:
            cve_id = get_cve_id(entry.title)
            if cve_id not in existing_ids:
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                new_item = {
                    'id': len(existing_data) + new_entries + 1,
                    'cve_id': cve_id,
                    'title': entry.title,
                    'published': entry.published,
                    'link': entry.link,
                    'description': entry.description,
                    'timestamp': timestamp
                }
                existing_data.append(new_item)
                new_entries += 1
        
        # 总是写入文件，确保文件存在
        with open(DATA_FILE, 'w', encoding='utf-8') as f:
            json.dump(existing_data, f, ensure_ascii=False, indent=2)
        
        print(f"拉取完成，新增{new_entries}条记录")
        return new_entries
        
    except Exception as e:
        print(f"拉取失败: {str(e)}")
        return 0

def send_report(force_send=False):
    try:
        if not os.path.exists(DATA_FILE) or os.path.getsize(DATA_FILE) == 0:
            print("无数据可发送")
            return
            
        today = datetime.now().strftime("%Y-%m-%d")
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        today_entries = []
        
        with open(DATA_FILE, 'r', encoding='utf-8') as f:
            existing_data = json.load(f)
            total_count = len(existing_data)
            for item in existing_data:
                if today in item['timestamp']:
                    today_entries.append(item)
        
        if not today_entries and not force_send:
            print(f"{now} - 今日无新增漏洞，不发送邮件")
            return
        
        subject = f"【CVE漏洞监控报告】{today} {len(today_entries)}个高风险漏洞"
        
        html_content = f"""
        <html>
          <body>
            <h2>{subject}</h2>
            <p>您好，以下是截至{now}监控到的高风险CVE漏洞信息：</p>
            <p><strong>今日新增：{len(today_entries)}个 | 累计总数：{total_count}个</strong></p>
            
            <table border="1" cellpadding="8" style="border-collapse:collapse; width:100%;">
              <tr style="background-color:#f2f2f2;">
                <th>序号</th>
                <th>CVE编号</th>
                <th>标题</th>
                <th>发布时间</th>
                <th>链接</th>
              </tr>
        """
        
        for entry in today_entries:
            html_content += f"""
              <tr>
                <td>{entry['id']}</td>
                <td>{entry['cve_id']}</td>
                <td>{entry['title']}</td>
                <td>{entry['published']}</td>
                <td><a href="{entry['link']}">查看详情</a></td>
              </tr>
            """
        
        html_content += """
            </table>
            <p>详细内容请查看附件JSON文件。</p>
            <p>-- GitHub Actions自动监控系统</p>
          </body>
        </html>
        """
        
        msg = MIMEMultipart()
        msg['From'] = SENDER_EMAIL
        msg['To'] = RECIPIENT_EMAIL
        msg['Subject'] = subject
        
        msg.attach(MIMEText(html_content, 'html', 'utf-8'))
        
        attachment = MIMEBase('application', 'octet-stream')
        with open(DATA_FILE, 'rb') as f:
            attachment.set_payload(f.read())
        encoders.encode_base64(attachment)
        attachment.add_header(
            'Content-Disposition',
            f'attachment; filename="cve_vulnerabilities_{today}.json"'
        )
        msg.attach(attachment)
        
        with smtplib.SMTP_SSL(SMTP_SERVER, SMTP_PORT) as server:
            server.login(SENDER_EMAIL, SENDER_PASSWORD)
            server.send_message(msg)
        
        print(f"{now} - 邮件发送成功，发送至{RECIPIENT_EMAIL}")
        
    except Exception as e:
        print(f"{now} - 邮件发送失败: {str(e)}")

if __name__ == "__main__":
    # 记录开始时间
    start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"{start_time} - 脚本开始运行")
    
    # 检查运行模式
    run_mode = os.environ.get("RUN_MODE", "fetch_data")
    
    if run_mode == "send_email":
        print(f"{start_time} - 执行模式: 发送邮件报告")
        send_report(force_send=True)
    else:
        print(f"{start_time} - 执行模式: 获取并保存CVE数据")
        new_entries = fetch_and_save_cve()
        
        # 每15分钟更新后，如果有新数据则发送邮件
        if new_entries > 0:
            print(f"{start_time} - 发现{new_entries}条新数据，发送邮件通知")
            send_report()
        
    # 记录结束时间
    end_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"{end_time} - 脚本运行结束")